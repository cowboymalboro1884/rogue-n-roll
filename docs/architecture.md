# Архитектурное описание Roguelike игры

## 1. Общие сведения о системе
Система представляет собой компьютерную игру в жанре Roguelike, разрабатываемую для запуска в консольном/терминальном окружении. Игра характеризуется пошаговым геймплеем, процедурной генерацией уровней (за исключением некоторых заданных), перманентной смертью персонажа, сложной системой правил и высокой степенью свободы действий игрока. Основная цель – предоставить игроку уникальный и реиграбельный опыт исследования подземелий, сражений с монстрами, сбора экипировки и выполнения квестов.

## 2. Architectural Drivers (Архитектурные драйверы)
Ключевые факторы, влияющие на архитектурные решения:

-   **Реиграбельность:** Основа жанра. Процедурная генерация карт, предметов, монстров и квестов должна быть центральным элементом.
-   **Расширяемость:** Возможность легко добавлять новые типы монстров, предметов, заклинаний, механик, квестов и правил без значительной переработки ядра системы.
-   **Производительность:** Несмотря на простую графику, генерация больших карт и обработка сложной логики (особенно AI) должны быть достаточно быстрыми, чтобы не вызывать заметных задержек в пошаговом режиме.
-   **Модульность:** Разделение системы на независимые компоненты (генерация карт, боевая система, инвентарь, AI, рендеринг и т.д.) для упрощения разработки, тестирования и поддержки.
-   **Тестируемость:** Особенно важно для систем со случайной генерацией; возможность тестировать отдельные модули (например, генератор карт или боевую логику) изолированно.
-   **Сложность правил:** Система должна поддерживать большое количество взаимодействующих правил и состояний.
-   **Управляемость данных:** Эффективное хранение и доступ к данным об игровом мире, персонажах, предметах и т.д.

## 3. Роли и случаи использования
**Роли:**

-   Игрок (Player): Единственный активный пользователь системы.

**Основные случаи использования (Use Cases):**

-   **UC-01: Начать новую игру**
    -   Игрок выбирает опцию "Новая игра".
    -   Система генерирует стартовый уровень (или загружает предопределенный), персонажа с базовыми характеристиками и инвентарем.
-   **UC-02: Перемещать персонажа**
    -   Игрок нажимает клавиши управления движением.
    -   Система проверяет возможность перемещения в указанную клетку.
    -   Система обновляет позицию персонажа на карте и перерисовывает экран.
    -   Ход переходит к другим сущностям (монстрам).
-   **UC-03: Взаимодействовать с окружением (Поднять предмет)**
    -   Персонаж находится на клетке с предметом.
    -   Игрок нажимает клавишу "Поднять предмет".
    -   Система добавляет предмет в инвентарь персонажа и удаляет его с карты.
-   **UC-04: Управлять инвентарем**
    -   Игрок открывает экран инвентаря.
    -   **UC-04.1: Надеть предмет:** Игрок выбирает предмет и опцию "Надеть". Система перемещает предмет в слот экипировки и обновляет характеристики персонажа.
    -   **UC-04.2: Снять предмет:** Игрок выбирает экипированный предмет и опцию "Снять". Система перемещает предмет обратно в инвентарь и обновляет характеристики персонажа.
    -   **UC-04.3: Выбросить предмет:** Игрок выбирает предмет и опцию "Выбросить". Система удаляет предмет из инвентаря и помещает его на текущую клетку карты.
-   **UC-05: Атаковать врага**
    -   Игрок выбирает направление атаки (или цель, если враг рядом).
    -   Система рассчитывает исход атаки на основе характеристик персонажа и врага.
    -   Система обновляет здоровье врага (и возможно персонажа, если враг контратакует).
    -   Ход переходит к другим сущностям.
-   **UC-06: Посмотреть характеристики персонажа**
    -   Игрок открывает экран характеристик.
    -   Система отображает текущие значения здоровья, силы атаки и т.д.
-   **UC-07: Управлять квестами**
    -   **UC-07.1: Получить квест:** Персонаж взаимодействует с NPC или триггером, инициирующим квест. Система добавляет квест в журнал.
    -   **UC-07.2: Посмотреть активные квесты:** Игрок открывает журнал квестов.
    -   **UC-07.3: Выполнить квест:** Система проверяет условия выполнения квеста. При выполнении – выдает награду и помечает квест как выполненный.
-   **UC-08: Завершить игру (Смерть персонажа)**
    -   Здоровье персонажа достигает нуля.
    -   Система отображает сообщение "Игра окончена" и, возможно, статистику.
    -   Возможность начать новую игру (без загрузки сохранения).
-   **UC-09: Перейти на следующий уровень**
    -   Персонаж достигает точки перехода (например, лестницы).
    -   Система генерирует новый уровень (или загружает предопределенный) и размещает на нем персонажа.

## 4. Описание типичного пользователя
Типичный пользователь – игрок, знакомый с жанром Roguelike или классическими RPG. Он ценит:

-   Вызов и сложность: Готов к частым неудачам (перманентная смерть) и обучению на ошибках.
-   Глубину геймплея: Интересуется изучением сложных правил, взаимодействий предметов и способностей.
-   Реиграбельность: Предпочитает игры, которые предлагают новый опыт при каждом прохождении.
-   Атмосферу исследования и открытий: Любит исследовать случайно сгенерированные миры.
-   Свободу действий: Ценит возможность выбирать свой путь и стиль игры. Ему не так важна передовая графика, сколько увлекательный и продуманный игровой процесс.

## 5. Композиция (диаграмма компонентов с описанием)

[Здесь](./components.md)

## 6. Логическая структура (диаграмма классов с описанием)
(Концептуальная диаграмма классов, не исчерпывающая)

[Здесь](./logistic.md)

## 7. Взаимодействия и состояния

[Здесь](./interactions.md)

## 8. Описание данных присутствующих в программе
**Данные персонажа (Player Data):**
-   Координаты (x, y) на карте.
-   Характеристики: здоровье (текущее/максимальное), мана (если есть), сила атаки, защита, уклонение, скорость и т.д.
-   Инвентарь: список предметов.
-   Экипированные предметы: предметы в слотах (голова, торс, оружие и т.д.).
-   Опыт, уровень.
-   Список активных/завершенных квестов.
-   Состояние (голод, отравление и т.д.). - опционально

**Данные монстров/NPC (Entity Data):**
-   Тип монстра/NPC.
-   Координаты (x, y) на карте.
-   Характеристики (аналогично игроку).
-   Модель поведения AI (агрессивный, пассивный, убегающий).
-   Возможный лут после смерти.
-   Диалоги (для NPC).

**Данные предметов (Item Data):**
-   ID, Название, Описание.
-   Тип (оружие, броня, зелье, свиток, еда и т.д.).
-   Свойства:
    -   Для оружия: урон, тип урона, скорость атаки.
    -   Для брони: защита, слот экипировки.
    -   Для зелий/свитков: эффект при использовании (восстановление HP, бафф/дебафф).
-   Вес, стоимость (если есть торговля).
-   Графическое представление (символ, цвет).

**Данные карты (Map Data):**
-   Размеры (ширина, высота).
-   Двумерный массив тайлов: тип тайла (стена, пол, дверь, вода), проходимость, прозрачность для света.
-   Расположение статических объектов (лестницы, сундуки, алтари).
-   Информация об исследованных/неисследованных областях.
-   Список предметов, лежащих на земле (координаты -&gt; список предметов).
-   Список монстров/NPC на карте с их текущим состоянием.

**Данные квестов (Quest Data):**
-   ID, Название, Описание.
-   Тип квеста (убить X монстров, найти предмет, дойти до точки).
-   Цели: список условий для выполнения.
-   Награды: опыт, предметы, деньги.
-   Статус (не взят, активен, выполнен, провален).
-   Возможно, информация о квестодателе.

**Конфигурационные данные (Configuration Data):**
-   Шаблоны монстров, предметов, квестов (загружаются из файлов, например, JSON или XML).
-   Предопределенные карты уровней.
-   Настройки игры (сложность, управление).

**Состояние игры (Game State Data - для приостановки, не для сохранения после смерти):**
-   Полное состояние всех вышеперечисленных данных на момент сохранения (текущий уровень, состояние игрока, всех сущностей, предметов на карте). Важно: в Roguelike это обычно для "save & quit", а не для загрузки после смерти.

**Данные рендеринга:**
-   Символы и цвета для отображения различных объектов и UI-элементов.

## 9. Описание паттернов
-   **Состояние (State):** Для управления различными состояниями игры (MainMenu, Playing, Paused, GameOver, InventoryScreen). Классы GameState, PlayingState, MenuState и т.д. инкапсулируют поведение и переходы, специфичные для каждого состояния.
-   **Стратегия (Strategy):**
    -   Для AI монстров: разные классы стратегий (AggressiveAI, FleeingAI, PatrolAI) могут быть назначены монстрам для определения их поведения.
    -   Для генерации карт: различные алгоритмы генерации (DrunkardsWalkGenerator, BSPTreeGenerator, CellularAutomataGenerator) могут быть реализованы как стратегии.
-   **Компонент (Component) / Entity-Component-System (ECS) - (упрощенная версия):**
    Сущности (Entity) состоят из набора компонентов (RenderComponent, PhysicsComponent, AIComponent, StatsComponent, InventoryComponent). Это позволяет гибко определять поведение и свойства сущностей, добавляя/удаляя компоненты. Особенно полезно для "чрезвычайно развитого набора игровых правил" и "высокой свободы действий".
-   **Фабричный метод (Factory Method) / Абстрактная фабрика (Abstract Factory):**
    Для создания объектов различных типов (монстры, предметы, квесты) на основе конфигурационных данных или случайной генерации. MonsterFactory может создавать монстров разных типов, ItemFactory - предметы.
-   **Наблюдатель (Observer):**
    Для обновления UI при изменении данных (например, здоровье игрока изменилось - UI должен обновиться). PlayerStats могут уведомлять UIManager об изменениях.
    Система квестов может наблюдать за игровыми событиями (убийство монстра, подбор предмета) для обновления прогресса квеста.
-   **Команда (Command):**
    Для обработки ввода пользователя. Каждое действие игрока (движение, атака, использование предмета) может быть инкапсулировано в объект-команду (MoveCommand, AttackCommand). Это упрощает обработку ввода, позволяет реализовать пошаговую логику (команда выполняется, затем ход передается AI).
-   **Одиночка (Singleton):**
    Для глобально доступных менеджеров, таких как GameManager, InputHandler, ConsoleRenderer, QuestManager, если требуется только один экземпляр этих систем. Использовать с осторожностью, чтобы не затруднять тестируемость.
-   **Строитель (Builder):**
    Может использоваться для создания сложных объектов с множеством параметров конфигурации, таких как персонаж (PlayerBuilder) или сложный уровень карты (MapBuilder).
-   **Шаблонный метод (Template Method):**
    В базовом классе EntityAction (или подобном) может быть определен общий алгоритм выполнения действия (проверка условий, выполнение, затрата времени/энергии), а конкретные шаги реализуются в подклассах (MoveAction, AttackAction).

## 10. План приемки
План приемки будет состоять из набора тестов, проверяющих соответствие функциональным и ключевым нефункциональным требованиям.

**Функциональные тесты (примеры):**

-   **FT-01 (Перемещение):**
    -   Игрок может перемещаться по карте во всех допустимых направлениях (N, S, E, W, диагонали).
    -   Игрок не может перемещаться сквозь стены или непроходимые объекты.
-   **FT-02 (Генерация/Загрузка карты):**
    -   При старте новой игры генерируется случайная карта (проверить несколько запусков).
    -   При переходе на специальный уровень (например, level_x.map) загружается карта из соответствующего файла.
-   **FT-03 (Характеристики):**
    -   Начальные характеристики персонажа соответствуют заданным.
    -   Характеристики корректно отображаются на экране персонажа.
-   **FT-04 (Инвентарь и Предметы):**
    -   Предмет, лежащий на карте, можно поднять, и он появляется в инвентаре.
    -   Предмет из инвентаря (экипировка) можно надеть, при этом изменяются характеристики персонажа.
    -   Надетый предмет можно снять, он возвращается в инвентарь, характеристики возвращаются к исходным (до надевания этого предмета).
    -   Предмет из инвентаря можно выбросить, он появляется на карте.
-   **FT-05 (Бой):**
    -   Атака по монстру наносит урон, уменьшая его здоровье.
    -   Монстр атакует игрока, нанося урон.
    -   Монстр с 0 HP исчезает с карты (умирает).
-   **FT-06 (Перманентная смерть):**
    -   Когда здоровье игрока достигает 0, игра заканчивается.
    -   Нет возможности загрузить сохранение после смерти. Новая игра начинается с нуля.
-   **FT-07 (Консольная графика):**
    -   Карта, игрок, монстры, предметы корректно отображаются в консоли с использованием символов.
    -   Интерфейс (статы, инвентарь, сообщения) отображается четко.
-   **FT-08 (Квесты):**
    -   Можно получить основной сюжетный квест.
    -   Сайд-квесты генерируются (например, при взаимодействии с NPC или объектом).
    -   Выполнение условий квеста приводит к его завершению и получению награды.

**Тесты архитектурных драйверов (примеры):**

-   **ADT-01 (Реиграбельность):**
    -   Провести 10 запусков новой игры. Карты, расположение монстров и предметов должны быть различными (за исключением заданных элементов).
-   **ADT-02 (Расширяемость):**
    -   Добавить новый тип предмета (например, "Зелье Невидимости") с описанием его логики. Оценить сложность и количество изменений в коде. (Это скорее оценка дизайна на этапе разработки).
-   **ADT-03 (Производительность):**
    -   Замерить время генерации карты размером 100x100 тайлов. Оно не должно превышать N секунд.
    -   В сцене с 20 монстрами ход AI всех монстров не должен занимать более M миллисекунд.

**Критерии приемки:**
Система считается принятой, если:

-   Все функциональные тесты успешно пройдены.
-   Ключевые тесты архитектурных драйверов показывают приемлемые результаты.
-   Отсутствуют критические ошибки, блокирующие основной игровой процесс.
-   Пользовательский интерфейс интуитивно понятен и отзывчив (в рамках консольного приложения).